roll-out:
	move ISA selection to a generic parameter
	add valid and dirty flags to L1d
	implement flush of dirty line after refill
	schedule writes only once priors issued => speed-up
	allow writeback to an empty line (no miss before write)
	finalize optimization of fast adder equality
	implement load-alias detection CAM [0]
	implement write alias wake-up [1]
	implement TLB [3]
	add instruction and data prefetch?
	branch predictor - ITTAGE predictor
	add microcode for div
	support sext[bh] in slow? OR sextb=(andi 0x80, muli -1, or)
	try making non-faulting ops final once ready => IPC gain?
	implement FPU [5]

[0] use 2*M10k as a 32-entry 18-bit CAM of load address hashes

[1] make issue wake-up a strobe => allows reissue with same circuit
	... write’s final=>high concurrent to aliased load’s final+issued=>low

test program: mul, mul, mul, mul, write, load, load, load, load, load, load
=> check that all loads see same value

[3] include a nocache bit for IO mappings

[5] FPU ops take 4 cycles, but live in slow EUs
... to avoid additional write ports, add an extra bypass on slow memories.
	=> 3-cycle writes go into readable bypass register
	=> write-back happens on 4th cycle
	(just like how in-order CPUs do it)
