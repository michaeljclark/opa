issue - use the r_stat[ab] to MUX the result of scheduling
  scheduling then reports 1hot, saving the level of ORs
    ... can use s_pending(i) as load enable for "0" into r_schedule
    => 18 stations arbitrated to a register in exactly 2 levels
  scheduling reports per-unit selection AND a "<=#units" selection for s_ready
  this would make s_ready independent of the # of EUs (only on # types)

issue - if none of that makes it fast enough, add a pipeline stage
  the only absolute requirements are:
    the feedback from ready=>ready is 1 cycle
    the feedback from issued<=>pending is 1 cycle
  ... can thus decouple the "ready" stage and the "schedule" stage
  => increases the MINIMUM latency to 2 (for adders/etc)
  ... is a last resort!

renamer - if optimizing copies: leave them in place for commit to see

-- For memory unit (later):
-- B+W are always in-order
-- R is allowed to commute freely, EXCEPT:
-- it may only skip at most 'x' Ws

-- Assumption: reads are side-effect free (even on devices!)
-- Write-through cache ... want spills to be hot
-- reads specify if they can be cached and how far they commute
-- ... how does this interact with calling ABI? (callee/caller-saved)

decode - put aux into MLAB/M9k 
  just a single writer that puts all the stuff in for all ops at once
  put a reference into the renamer
  just need EU* copies of the memory and pull it 1st step of regfile 
   (must be a register when it reaches EU)
  => can help with using 64-bit wide immediates

---------------------------------------------------------------------------------------------------------------------

TODO:
  remove 3D arrays from arbitration
----
memory unit
fetcher
branches
